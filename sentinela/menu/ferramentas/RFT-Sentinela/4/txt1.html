<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>TXT1 — Processar Perguntas (RTF)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
/* Estilos originais do txt1.html mantidos */
html, body { height: 100%; margin: 0; padding: 0; font-family: system-ui, -apple-system, Arial, sans-serif; background: #f5f7fa; }
body { max-width: 100vw; padding: 0 3vw 6vw; box-sizing: border-box; }
h2 { margin: 16px 0 10px; font-size: 1rem; font-weight: 600; color: #2b3a55; }
.tabs { position: sticky; top: 0; z-index: 5; display: flex; gap: 8px; padding: 10px 0; background: #f5f7fa; }
.tabs a { flex: 1; text-align: center; text-decoration: none; font-size: .9em; padding: .55em .7em; border-radius: 8px; background: #fff; color: #2b3a55; border: 1px solid #d6dae3; box-shadow: 0 1px 2.5px #0001; }
.tabs a.active { background: #3264b2; color: #fff; border-color: #3264b2; }
.actions { display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0; }
.btn { font-size: .88em; padding: .55em .95em; border-radius: 9px; border: 1px solid transparent; box-shadow: 0 1px 2.5px #0001; min-height: 36px; cursor: pointer; transition: transform .06s, background .12s, border-color .12s; }
.btn:active { transform: translateY(1px); }
.btn-primary { background: #3264b2; color: #fff; }
.btn-secondary { background: #eef3ff; color: #274f8e; border-color: #c9d7fb; }
.btn-success { background: #23b94d; color: #fff; }
input[type="file"] { font-size: 0.88em; padding: .5em .8em; margin: 8px 0; border-radius: 8px; border: 1px dashed #aaa; background: #fff; }
textarea { width: 100%; font-size: 0.86em; border-radius: 9px; box-sizing: border-box; border: 1px solid #b8bac7; background: #fff; resize: vertical; margin: 8px 0 12px; line-height: 1.4; transition: border .13s; font-family: inherit; padding: 1em; }
textarea:focus { border-color: #3264b2; outline: none; }
#inputArea { min-height: 140px; max-height: 40vh; }
#outputArea { min-height: 520px; max-height: 80vh; }
@media (min-width: 900px) {
  body { max-width: 520px; margin: 32px auto; }
  .tabs a { flex: unset; }
  textarea { font-size: 0.92em; }
}
  </style>
  <script src="bbl.js"></script>
</head>
<body>
<nav class="tabs">
  <a href="txt1.html" class="active">TXT1</a>
  <a href="txt2.html">TXT2</a>
  <a href="txt3.html">TXT3</a>
  <a href="txt4.html">TXT4</a>
</nav>

  <h2>Importar RTF e transformar "Pergunta X" em "X."</h2>
  
  <input type="file" id="fileInput" accept=".rtf,text/rtf">
  <textarea id="inputArea" placeholder="Cole ou importe o arquivo .rtf aqui..." autocapitalize="sentences" autocorrect="on"></textarea>

  <div class="actions">
    <button class="btn btn-primary" onclick="processar()">Processar</button>
    <button id="copyBtn" class="btn btn-secondary" onclick="copiarResultado()">Copiar</button>
    <span style="flex: 1 1 auto;"></span>
    <button id="sendBtn" class="btn btn-primary" onclick="enviarParaTXT2()">Enviar para TXT2</button>
  </div>

  <textarea id="outputArea" readonly placeholder="Resultado..."></textarea>

<script>
(() => {
  // ===================================================================
  // INÍCIO DO PARSER RTF (Sem alterações)
  // ===================================================================

  const CP1252 = (() => {
    const map = [];
    for (let i=0;i<256;i++) map[i] = String.fromCharCode(i);
    const spec = {0x80:'€',0x82:'‚',0x83:'ƒ',0x84:'„',0x85:'…',0x86:'†',0x87:'‡',0x88:'ˆ',0x89:'‰',0x8A:'Š',0x8B:'‹',0x8C:'Œ',0x8E:'Ž',0x91:'‘',0x92:'’',0x93:'“',0x94:'”',0x95:'•',0x96:'–',0x97:'—',0x98:'˜',0x99:'™',0x9A:'š',0x9B:'›',0x9C:'œ',0x9E:'ž',0x9F:'Ÿ'};
    for (const k in spec) map[+k] = spec[k];
    return map;
  })();

  function hexByteToChar(hh) {
    const n = parseInt(hh, 16);
    return Number.isFinite(n) ? CP1252[n] || '' : '';
  }

  function readBalanced(src, start) {
    let i = start, depth = 0;
    do {
      const ch = src[i++];
      if (ch === '\\') { const next = src[i]; if (next === '{' || next === '}' || next === '\\') i++; continue; }
      if (ch === '{') depth++; else if (ch === '}') depth--;
    } while (i < src.length && depth > 0);
    return { end: i, text: src.slice(start, i) };
  }

  function stripRtf(rtfChunk) {
    let s = rtfChunk;
    if (s[0] === '{' && s[s.length-1] === '}') s = s.slice(1, -1);
    s = s.replace(/\\\\/g, '\\').replace(/\\\{/g, '{').replace(/\\\}/g, '}');
    s = s.replace(/\\u(-?\d+)([^\d-])?/g, (_, num) => { try { return String.fromCodePoint(parseInt(num, 10)); } catch { return ''; } });
    s = s.replace(/\\'([0-9a-fA-F]{2})/g, (_, hh) => hexByteToChar(hh));
    s = s.replace(/\\par\b/g, '\n\n').replace(/\\line\b/g, '\n').replace(/\\tab\b/g, '\t');
    s = s.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');
    s = s.replace(/[{}]/g, '');
    return s;
  }
  
  function parseFieldAt(rtf, start) {
    const { end, text: group } = readBalanced(rtf, start);
    let resultText = '';
    const idx = group.search(/\\fldrslt\b/i);
    if (idx !== -1) {
      const after = group.slice(idx);
      const bracePos = after.indexOf('{');
      if (bracePos !== -1) {
        const inner = readBalanced(after, bracePos);
        resultText = stripRtf(inner.text);
      } else {
        resultText = stripRtf(after.replace(/^\\fldrslt\b/, ''));
      }
    }
    return { html: resultText, end };
  }

  const SKIP_GROUPS = new Set(['fonttbl','colortbl','stylesheet','info','*symbol','*panose','*generator','pict','nonshppict','object','*datastore','filetbl','revtbl','rsidtbl','*rsidtbl','shpinst','shppict','*xmlopen','*xmlnstbl','xmlopen','xe','tc','mmath','*mmathPr']);

  function shouldSkipGroup(name) {
    if (!name) return false;
    const n = name.toLowerCase();
    return SKIP_GROUPS.has(n) || n === '*';
  }

  function rtfToText(rtf) {
    let i = 0, text = '';
    const len = rtf.length;
    while (i < len) {
      const ch = rtf[i];
      if (ch === '{') {
        const m = rtf.slice(i + 1, i + 50).match(/^\\\*?([A-Za-z]+)/);
        const name = m && m[1] ? m[1].toLowerCase() : '';
        if (name === 'field') {
          const { html: h, end } = parseFieldAt(rtf, i);
          text += h;
          i = end;
          continue;
        }
        if (shouldSkipGroup(name)) {
          const { end } = readBalanced(rtf, i);
          i = end;
          continue;
        }
        i++; continue;
      }
      if (ch === '}') { i++; continue; }
      if (ch === '\\') {
        const next = rtf[i+1];
        if (next === '{' || next === '}' || next === '\\') { text += next; i += 2; continue; }
        if (next === "'") {
          const hh = rtf.slice(i+2, i+4);
          if (/^[0-9a-fA-F]{2}$/.test(hh)) { text += hexByteToChar(hh); i += 4; continue; }
        }
        
        const mu = rtf.slice(i).match(/^\\u(-?\d+)(.)?/);
        if (mu) {
          let code = parseInt(mu[1], 10);
          if (code < 0) { code += 65536; }
          try { text += String.fromCodePoint(code); } catch {}
          i += mu[0].length;
          continue;
        }
        
        const mw = rtf.slice(i).match(/^\\([a-zA-Z]+)(-?\d+)?\s?/);
        if (mw) {
          const word = mw[1].toLowerCase();
          switch (word) {
            case 'par': text += '\n\n'; break;
            case 'line': text += '\n'; break;
            case 'tab': text += '\t'; break;
            case 'emdash': text += '—'; break;
            case 'endash': text += '–'; break;
            case 'lquote': text += '‘'; break;
            case 'rquote': text += '’'; break;
            case 'ldblquote': text += '“'; break;
            case 'rdblquote': text += '”'; break;
          }
          i += mw[0].length;
          continue;
        }
        i++; continue;
      }
      text += ch;
      i++;
    }
    return text.replace(/\n{3,}/g, '\n\n').replace(/^[ \t]+|[ \t]+$/gm, '').trim();
  }

  document.getElementById('fileInput').addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      const rtfContent = String(reader.result || '');
      let plainText = rtfToText(rtfContent);
      plainText = plainText.replace(/^\*WTS5;\s*/, '');
      document.getElementById('inputArea').value = plainText;
    };
    reader.onerror = () => alert('Não foi possível ler o arquivo. Tente novamente.');
    reader.readAsText(f);
  });

  // ===================================================================
  // FIM DO PARSER RTF. LÓGICA DA PIPELINE ATUALIZADA ABAIXO.
  // ===================================================================

  // **NOVO (CORRIGIDO):** Função para processar referências bíblicas
  function processarReferencias(str) {
    if (!str) return str;
    
    // **NOVO:** Converte "Primeiro/a", "Segundo/a" de forma inteligente, apenas se seguido por letra maiúscula
    str = str.replace(/\b[Pp]rimeir[ao]\s+(?=[A-ZÀ-Ú])/g, '1 ');
    str = str.replace(/\b[Ss]egund[ao]\s+(?=[A-ZÀ-Ú])/g, '2 ');
    str = str.replace(/\b[Tt]erceira?\s+(?=[A-ZÀ-Ú])/g, '3 ');

    // Converte "Salmo X versículo Y" para "Salmo X:Y"
    str = str.replace(/(Salmo[s]?|SALMO[S]?)\s+(\d+)\s+versículo[s]?\s+(\d+)(?:\s*,\s*(\d+))?(?:\s*a\s*(\d+))?/gi, function(_m, livro, num, v1, v2, vfaixa) { if (vfaixa) return `${livro} ${num}:${v1}-${vfaixa}`; if (v2) return `${livro} ${num}:${v1}, ${v2}`; return `${livro} ${num}:${v1}`; });

    // Converte "Livro capítulo X versículos Y" para "Livro X:Y"
    str = str.replace(/((?:[1-3]\s+)?[A-ZÀ-Úa-zà-ú][\wÀ-ÿ\s]+?)\s+cap[íi]tulo\s+(\d+)\s+(versículo|versículos)\s+(\d+)(?:\s*,\s*(\d+))?(?:\s*a\s*(\d+))?/gi, function (_m, livro, cap, _tipo, v1, v2, vfaixa) { if (vfaixa) return `${livro} ${cap}:${v1}-${vfaixa}`; if (v2) return `${livro} ${cap}:${v1}, ${v2}`; return `${livro} ${cap}:${v1}`; });
    
    // Converte "capítulo X versículos Y" (sem nome de livro) para "X:Y" se já houver uma referência antes
    str = str.replace(/(^|(?:[;,]\s*|\s+[Ee]\s+))([Cc]ap[íi]tulo)s?\s+(\d+)\s+(versículo|versículos)\s+(\d+)(?:\s*,\s*(\d+))?(?:\s*a\s*(\d+))?/g, function (match, sep, _capWord, cap, _tipo, v1, v2, vfaixa, offset, s) { const left = s.slice(0, offset); const reLivro = /((?:[1-3]\s+)?[A-ZÀ-Úa-zà-ú][\wÀ-ÿ\s]+?)\s+\d+:\d+(?:\s*[-,]\s*\d+)?/g; let m, ultimoLivro = null; while ((m = reLivro.exec(left)) !== null) ultimoLivro = (m[1] || '').trim(); if (!ultimoLivro) return match; const vers = vfaixa ? `${cap}:${v1}-${vfaixa}` : (v2 ? `${cap}:${v1}, ${v2}` : `${cap}:${v1}`); return (sep || '') + vers; });
    
    return str;
  }

  function abreviarLivrosBiblicos(texto) {
    if (typeof abreviacoesBiblicas !== 'object') return texto;
    const livros = Object.keys(abreviacoesBiblicas).sort((a, b) => b.length - a.length);
    livros.forEach(livro => { const reg = new RegExp(`\\b${livro}\\s(?=\\d+:)`, 'g'); texto = texto.replace(reg, abreviacoesBiblicas[livro] + ' '); });
    return texto;
  }

  // **NOVO (CORRIGIDO):** Função principal de processamento
  window.processar = function() {
    let texto = document.getElementById('inputArea').value;

    // **NOVO:** Lógica de processamento de imagem revisada
    let imgCount = 0;
    const reBlocoImagem = /\[Imagem:\][\s\S]*?(?=Pergunta\s+\d+\.)/gi;
    texto = texto.replace(reBlocoImagem, () => {
      imgCount++;
      return `<div class="imagem${imgCount}"></div>\n\n`;
    });

    // Limpeza geral
    texto = texto.replace(/\[Quadro\]\s*Objetivo\s*\n+([\s\S]*?)\s*\[Fim do quadro\.\]/gi, (_m, conteudo) => 'Objetivo\n' + (conteudo || '').trim());
    texto = texto.replace(/\(\s*\*\s*\)/g, '*');
    texto = texto.replace(/\[Nota para o leitor\.\][\s\S]*?\[Fim da nota para o leitor\.\]/g, '');
    texto = texto.replace(//g, '• '); // Converte ícone para bullet

    // Formatação das perguntas
    texto = texto.replace(/\n?(Pergunta\s+\d+(\s+a\s+\d+)?)/g, '\n\n$1');
    texto = texto.replace(/Pergunta\s+(\d+)\s+a\s+(\d+)\./g, '$1-$2.');
    texto = texto.replace(/Pergunta\s+(\d+)\./g, '$1.');

    // **NOVO (REMOVIDO):** A linha que removia reticências foi deletada
    // texto = texto.replace(/\.(?=\.)/g, ''); // <== LINHA REMOVIDA

    // **NOVO (CORRIGIDO):** Aplica a conversão de referências em todo o texto
    texto = processarReferencias(texto);

    // Formatação de títulos (mantido)
    texto = texto.replace(/([^\n])\n([^\n\.\:\[\d][^\n\.\:\[]*)\n/g, (match, prev, titulo) => prev + '\n\n' + titulo + '\n');
    
    // Processamento de notas de rodapé (mantido)
    let notasRodape = [];
    texto = texto.replace(/\[Nota\]([\s\S]*?)\[Fim da nota\.\]/g, function(_m, conteudo) { let idx = notasRodape.length; let simbolo = ['*', '#', '+'][idx] || '+'; conteudo = (conteudo || '').trim().replace(/^([*#+])\s*/, ''); notasRodape.push(simbolo + ' ' + conteudo); return ''; });
    let notas = [];
    texto = texto.replace(/\[Nota[\s\S]*?\[Fim da nota\.\]/g, (m) => { notas.push(m.trim()); return ''; });
    texto = texto.replace(/\[Leitura[\s\S]*?\[Fim da leitura\.\]/g, '');
    let todasNotas = notasRodape.concat(notas);
    if (todasNotas.length > 0) { texto = texto.trim() + '\n\n' + todasNotas.join('\n\n'); }

    // Abreviação final dos livros
    texto = abreviarLivrosBiblicos(texto);

    // Finalização e output
    document.getElementById('outputArea').value = texto.trim();
    const copyBtn = document.getElementById('copyBtn');
    copyBtn.classList.remove('btn-success');
    copyBtn.innerText = 'Copiar';
    const sendBtn = document.getElementById('sendBtn');
    sendBtn.classList.remove('btn-success');
    sendBtn.innerText = 'Enviar para TXT2';
  }

  // Funções dos botões (sem alterações)
  window.copiarResultado = function() {
    const output = document.getElementById('outputArea');
    if (!output.value.trim()) return;
    output.select();
    document.execCommand('copy');
    const btn = document.getElementById('copyBtn');
    btn.classList.add('btn-success');
    btn.innerText = 'Copiado!';
    setTimeout(() => { btn.classList.remove('btn-success'); btn.innerText = 'Copiar'; }, 1300);
  }
  window.enviarParaTXT2 = function() {
    if (!document.getElementById('outputArea').value.trim() && document.getElementById('inputArea').value.trim()) { window.processar(); }
    const conteudo = document.getElementById('outputArea').value.trim();
    if (!conteudo) { alert('Nada a enviar. Processe um texto primeiro.'); return; }
    localStorage.setItem('TXT2_SEMENTE', conteudo);
    const btn = document.getElementById('sendBtn');
    btn.classList.add('btn-success');
    btn.innerText = 'Enviado!';
    window.location.href = 'txt2.html';
  }
})();
</script>
</body>
</html>