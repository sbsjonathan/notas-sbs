<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Eyedropper móvel com lupa</title>
  <style>
    :root{
      --bg:#0f1115; --card:#151822; --text:#e6e8ef; --muted:#98a2b3; --brand:#4f46e5; --ring:#6366f1;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--text); font-family: -apple-system,BlinkMacSystemFont, "SF Pro Text", Inter, Roboto, system-ui, Segoe UI, Arial, sans-serif}

    .wrap{display:flex; flex-direction:column; height:100%;}

    header{
      position:sticky; top:0; z-index:10; backdrop-filter:saturate(1.2) blur(10px);
      background:linear-gradient(180deg, rgba(21,24,34,.95), rgba(21,24,34,.85));
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .bar{display:flex; align-items:center; gap:.5rem; padding:.7rem .9rem;}
    .title{font-weight:700; letter-spacing:.2px}
    .spacer{flex:1}

    .btn{appearance:none; border:1px solid rgba(255,255,255,.12); background:#1a1f2d; color:var(--text);
      border-radius:14px; padding:.55rem .8rem; font-weight:600; font-size:.95rem; box-shadow:var(--shadow);
      display:inline-flex; align-items:center; gap:.5rem}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:var(--brand); border-color:transparent}
    .btn.outline{background:transparent}
    .btn.small{padding:.45rem .6rem; font-size:.9rem}

    .controls{display:flex; gap:.5rem; overflow:auto hidden}

    .panel{padding:.6rem .9rem; background:var(--card); border-top:1px solid rgba(255,255,255,.06);
      display:grid; grid-template-columns: 1fr auto; align-items:center; gap:.6rem;}

    .swatch{width:44px; height:44px; border-radius:12px; border:1px solid rgba(255,255,255,.15); box-shadow:var(--shadow)}

    .readout{display:grid; grid-template-columns: 1fr; gap:.35rem}
    .row{display:flex; align-items:center; gap:.5rem}
    input.hex{width:100%; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:#0f1320; color:var(--text); padding:.65rem .7rem; border-radius:12px;
      border:1px solid rgba(255,255,255,.12); box-shadow: inset 0 1px 0 rgba(255,255,255,.04)}

    .canvasBox{position:relative; flex:1; overflow:hidden; background:#0b0d13}
    canvas{display:block; max-width:100%; width:100%; height:100%; touch-action:none}

    /* Lupa */
    .loupe{position:absolute; width:110px; height:110px; border-radius:999px; overflow:hidden;
      border:2px solid rgba(255,255,255,.8); box-shadow:var(--shadow); pointer-events:none;
      background:#000}
    .loupe.hidden{display:none}
    .loupeCanvas{width:100%; height:100%;}
    .crosshair{position:absolute; left:50%; top:50%; width:0; height:0;
      border-left:11px solid transparent; border-right:11px solid transparent;
      border-top:11px solid rgba(255,255,255,.95); transform:translate(-50%,-50%)}
    .loupeLabel{position:absolute; bottom:6px; left:50%; transform:translateX(-50%);
      padding:.22rem .5rem; border-radius:999px; font:700 .78rem/1 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:rgba(0,0,0,.65); color:#fff; border:1px solid rgba(255,255,255,.18)}

    .hint{font-size:.82rem; color:var(--muted)}

    /* iOS safe areas */
    @supports(padding:max(0px)){
      header{padding-top: env(safe-area-inset-top)}
      .panel{padding-bottom: calc(.6rem + env(safe-area-inset-bottom))}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="bar">
        <div class="title">Detector de Cores — Móvel</div>
        <div class="spacer"></div>
        <div class="controls">
          <label class="btn outline small">
            <input id="fileInput" type="file" accept="image/*" hidden>
            Abrir imagem
          </label>
          <label class="btn primary small">
            <input id="cameraInput" type="file" accept="image/*;capture=environment" hidden>
            Câmera
          </label>
          <button id="clearBtn" class="btn outline small" aria-label="Limpar">Limpar</button>
        </div>
      </div>
    </header>

    <div class="canvasBox" id="canvasBox">
      <canvas id="canvas" aria-label="Área da imagem para escolher cor"></canvas>
      <div id="loupe" class="loupe hidden" role="img" aria-label="Lupa de zoom">
        <canvas id="loupeCanvas" class="loupeCanvas"></canvas>
        <div class="crosshair" aria-hidden="true"></div>
        <div id="loupeLabel" class="loupeLabel">#000000</div>
      </div>
    </div>

    <div class="panel">
      <div class="readout">
        <div class="row">
          <input id="hexField" class="hex" value="#000000" inputmode="text" autocapitalize="off" autocorrect="off" spellcheck="false" aria-label="Cor em hexadecimal" />
          <button id="copyBtn" class="btn outline small">Copiar</button>
        </div>
        <div class="row hint">Toque e arraste sobre a imagem para usar a lupa. Toque rápido para fixar a cor.</div>
      </div>
      <div id="swatch" class="swatch" aria-label="Amostra"></div>
    </div>
  </div>

  <script>
    // Utilidades de cor
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    function toHex(n){ return (n|0).toString(16).padStart(2,'0'); }
    function rgbToHex(r,g,b){ return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase(); }

    // Elementos
    const box = document.getElementById('canvasBox');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const loupe = document.getElementById('loupe');
    const loupeCanvas = document.getElementById('loupeCanvas');
    const lctx = loupeCanvas.getContext('2d', { willReadFrequently: true });
    const loupeLabel = document.getElementById('loupeLabel');
    const swatch = document.getElementById('swatch');
    const hexField = document.getElementById('hexField');
    const copyBtn = document.getElementById('copyBtn');

    const fileInput = document.getElementById('fileInput');
    const cameraInput = document.getElementById('cameraInput');
    const clearBtn = document.getElementById('clearBtn');

    // Estado
    let img = new Image();
    let imgW = 0, imgH = 0;      // tamanho original
    let drawW = 0, drawH = 0;    // tamanho desenhado (fit)
    let offsetX = 0, offsetY = 0;// deslocamento dentro do canvas
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let fixedSample = false;     // cor fixada após tap

    // Ajusta tamanho do canvas para alta densidade
    function resizeCanvas(){
      const rect = box.getBoundingClientRect();
      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      drawImageFit();
      resizeLoupe();
    }

    function resizeLoupe(){
      const lw = loupe.clientWidth || 110; const lh = loupe.clientHeight || 110;
      loupeCanvas.width = Math.floor(lw * dpr);
      loupeCanvas.height = Math.floor(lh * dpr);
    }

    function drawImageFit(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(!imgW || !imgH) return;
      const cw = canvas.width, ch = canvas.height;
      const scale = Math.min(cw / imgW, ch / imgH);
      drawW = Math.floor(imgW * scale);
      drawH = Math.floor(imgH * scale);
      offsetX = Math.floor((cw - drawW) / 2);
      offsetY = Math.floor((ch - drawH) / 2);
      ctx.drawImage(img, 0,0, imgW,imgH, offsetX,offsetY, drawW,drawH);
    }

    function loadImageFromFile(file){
      if(!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        const url = e.target.result;
        img = new Image();
        img.onload = ()=>{
          imgW = img.naturalWidth; imgH = img.naturalHeight;
          resizeCanvas();
          fixedSample = false; hideLoupe();
        };
        img.src = url;
      };
      reader.readAsDataURL(file);
    }

    // Coord display->pixel da imagem
    function displayToImagePixel(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const xCSS = clientX - rect.left; // em CSS px
      const yCSS = clientY - rect.top;
      const x = xCSS * dpr; // em canvas px
      const y = yCSS * dpr;
      // Fora da área desenhada? (considerando offsets)
      const insideX = clamp(x, offsetX, offsetX + drawW);
      const insideY = clamp(y, offsetY, offsetY + drawH);
      // Normaliza para a imagem original
      const u = (insideX - offsetX) / drawW; // 0..1
      const v = (insideY - offsetY) / drawH;
      const ix = clamp(Math.round(u * (imgW-1)), 0, imgW-1);
      const iy = clamp(Math.round(v * (imgH-1)), 0, imgH-1);
      return { ix, iy, xCSS, yCSS };
    }

    function sampleAt(clientX, clientY){
      if(!imgW || !imgH) return;
      const { ix, iy, xCSS, yCSS } = displayToImagePixel(clientX, clientY);
      // Lê um pequeno bloco para a lupa
      const block = 15; // metade do lado (em px da imagem original, será escalado)
      const sx = clamp(ix - block, 0, imgW-1);
      const sy = clamp(iy - block, 0, imgH-1);
      const sw = clamp(2*block+1, 1, imgW - sx);
      const sh = clamp(2*block+1, 1, imgH - sy);

      // Desenha área na lupa (ampliada)
      lctx.imageSmoothingEnabled = false; // efeito pixelado
      lctx.clearRect(0,0,loupeCanvas.width,loupeCanvas.height);
      lctx.drawImage(img, sx,sy, sw,sh, 0,0, loupeCanvas.width, loupeCanvas.height);

      // Cor do pixel central
      const centerData = lctx.getImageData(Math.floor(loupeCanvas.width/2), Math.floor(loupeCanvas.height/2), 1, 1).data;
      const [r,g,b,a] = centerData;
      const hex = rgbToHex(r,g,b);
      updateUI(hex);

      // Posiciona a lupa perto do dedo (acima)
      const lw = loupe.clientWidth; const lh = loupe.clientHeight;
      const pad = 8;
      let left = xCSS - lw/2;
      let top = yCSS - lh - 18;
      // Mantém na tela
      const rect = canvas.getBoundingClientRect();
      left = clamp(left, 6, rect.width - lw - 6);
      top = clamp(top, 6, rect.height - lh - 6);
      loupe.style.transform = `translate(${left}px, ${top}px)`;
      loupe.classList.remove('hidden');
      loupeLabel.textContent = hex;
    }

    function updateUI(hex){
      swatch.style.background = hex;
      hexField.value = hex;
      document.title = `Eyedropper — ${hex}`;
    }

    function hideLoupe(){ loupe.classList.add('hidden'); }

    // Interação por toque
    let touchTimer = null;
    let lastTouch = {x:0,y:0};

    function onTouchStart(e){
      if(!imgW){ return; }
      const t = e.touches[0];
      lastTouch = {x: t.clientX, y: t.clientY};
      sampleAt(t.clientX, t.clientY);
    }
    function onTouchMove(e){
      if(!imgW){ return; }
      const t = e.touches[0];
      lastTouch = {x: t.clientX, y: t.clientY};
      sampleAt(t.clientX, t.clientY);
    }
    function onTouchEnd(e){
      if(!imgW){ return; }
      // Tap curto fixa a amostra e mantém lupa um instante
      fixedSample = true;
      setTimeout(()=>{ hideLoupe(); }, 160);
    }

    // Interação por mouse (fallback)
    function onMouseDown(e){ if(!imgW) return; sampleAt(e.clientX, e.clientY); }
    function onMouseMove(e){ if(!imgW) return; if(e.buttons&1) sampleAt(e.clientX,e.clientY); }
    function onMouseUp(){ hideLoupe(); }

    // Arquivos
    fileInput.addEventListener('change', e => loadImageFromFile(e.target.files[0]));
    cameraInput.addEventListener('change', e => loadImageFromFile(e.target.files[0]));
    clearBtn.addEventListener('click', ()=>{
      imgW = imgH = 0; fixedSample=false; hideLoupe();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      updateUI('#000000');
    });

    // Copiar HEX
    copyBtn.addEventListener('click', async ()=>{
      try{
        await navigator.clipboard.writeText(hexField.value.trim());
        copyBtn.textContent = 'Copiado';
        setTimeout(()=>copyBtn.textContent='Copiar', 900);
      }catch{
        hexField.select(); document.execCommand('copy');
      }
    });

    // Atualiza a cor quando o usuário edita manualmente o campo
    hexField.addEventListener('input', ()=>{
      const v = hexField.value.trim();
      const ok = /^#?[0-9a-fA-F]{6}$/.test(v);
      if(ok){
        const hex = v.startsWith('#')? v : '#'+v;
        swatch.style.background = hex;
      }
    });

    // Eventos de ponteiro
    canvas.addEventListener('touchstart', onTouchStart, {passive:true});
    canvas.addEventListener('touchmove', onTouchMove, {passive:true});
    canvas.addEventListener('touchend', onTouchEnd, {passive:true});
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);

    // Resize / rotação
    let roTimer=null;
    const onResize = ()=>{ clearTimeout(roTimer); roTimer=setTimeout(()=>{ dpr=Math.max(1,window.devicePixelRatio||1); resizeCanvas(); }, 120); };
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);

    // Inicializa com uma grade neutra
    function drawChecker(){
      const w = canvas.width, h = canvas.height, s = Math.round(16*dpr);
      for(let y=0; y<h; y+=s){
        for(let x=0; x<w; x+=s){
          ctx.fillStyle = ((x+y)/s)%2? '#0e1017':'#0b0d13';
          ctx.fillRect(x,y,s,s);
        }
      }
    }

    function init(){
      resizeCanvas(); drawChecker(); updateUI('#000000');
    }
    init();
  </script>
</body>
</html>
