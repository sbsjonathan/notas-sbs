<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>TXT1 — Processar Perguntas (RTF)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
/* Estilos originais do txt1.html mantidos */
html, body { height: 100%; margin: 0; padding: 0; font-family: system-ui, -apple-system, Arial, sans-serif; background: #f5f7fa; }
body { max-width: 100vw; padding: 0 3vw 6vw; box-sizing: border-box; }
h2 { margin: 16px 0 10px; font-size: 1rem; font-weight: 600; color: #2b3a55; }
.tabs { position: sticky; top: 0; z-index: 5; display: flex; gap: 8px; padding: 10px 0; background: #f5f7fa; }
.tabs a { flex: 1; text-align: center; text-decoration: none; font-size: .9em; padding: .55em .7em; border-radius: 8px; background: #fff; color: #2b3a55; border: 1px solid #d6dae3; box-shadow: 0 1px 2.5px #0001; }
.tabs a.active { background: #3264b2; color: #fff; border-color: #3264b2; }
.actions { display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0; }
.btn { font-size: .88em; padding: .55em .95em; border-radius: 9px; border: 1px solid transparent; box-shadow: 0 1px 2.5px #0001; min-height: 36px; cursor: pointer; transition: transform .06s, background .12s, border-color .12s; }
.btn:active { transform: translateY(1px); }
.btn-primary { background: #3264b2; color: #fff; }
.btn-secondary { background: #eef3ff; color: #274f8e; border-color: #c9d7fb; }
.btn-success { background: #23b94d; color: #fff; }
input[type="file"] { font-size: 0.88em; padding: .5em .8em; margin: 8px 0; border-radius: 8px; border: 1px dashed #aaa; background: #fff; }
textarea { width: 100%; font-size: 0.86em; border-radius: 9px; box-sizing: border-box; border: 1px solid #b8bac7; background: #fff; resize: vertical; margin: 8px 0 12px; line-height: 1.4; transition: border .13s; font-family: inherit; padding: 1em; }
textarea:focus { border-color: #3264b2; outline: none; }
#inputArea { min-height: 140px; max-height: 40vh; }
#outputArea { min-height: 520px; max-height: 80vh; }

/* === NOVOS ESTILOS PARA O CARREGADOR DE URL === */
.url-loader { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
#urlInput { flex: 1; font-size: 0.88em; padding: .5em .8em; border-radius: 8px; border: 1px solid #aaa; min-height: 36px; box-sizing: border-box; }
.url-status { font-size: .8em; color: #555; white-space: nowrap; }
/* ============================================= */

@media (min-width: 900px) {
  body { max-width: 520px; margin: 32px auto; }
  .tabs a { flex: unset; }
  textarea { font-size: 0.92em; }
}
  </style>
  <script src="bbl.js"></script>
</head>
<body>
<nav class="tabs">
  <a href="txt1.html" class="active">TXT1</a>
  <a href="txt2.html">TXT2</a>
  <a href="txt3.html">TXT3</a>
  <a href="txt4.html">TXT4</a>
</nav>

  <h2>Importar RTF e transformar "Pergunta X" em "X."</h2>
  
  <!-- === HTML MODIFICADO: Adicionado campo de URL e botão === -->
  <p style="font-size: .8em; margin: 12px 0 -4px; color: #555;">Importar de um arquivo:</p>
  <input type="file" id="fileInput" accept=".rtf,text/rtf">
  
  <p style="font-size: .8em; margin: 12px 0 -4px; color: #555;">...ou de uma URL:</p>
  <div class="url-loader">
    <input type="url" id="urlInput" placeholder="Cole a URL do arquivo .rtf aqui...">
    <button class="btn btn-secondary" onclick="carregarDaURL()">Carregar</button>
    <span id="urlStatus" class="url-status"></span>
  </div>
  <!-- ======================================================== -->

  <textarea id="inputArea" placeholder="Cole ou importe o arquivo .rtf aqui..." autocapitalize="sentences" autocorrect="on"></textarea>

  <div class="actions">
    <button class="btn btn-primary" onclick="processar()">Processar</button>
    <button id="copyBtn" class="btn btn-secondary" onclick="copiarResultado()">Copiar</button>
    <span style="flex: 1 1 auto;"></span>
    <button id="sendBtn" class="btn btn-primary" onclick="enviarParaTXT2()">Enviar para TXT2</button>
  </div>

  <textarea id="outputArea" readonly placeholder="Resultado..."></textarea>

<script>
(() => {
  // ===================================================================
  // INÍCIO DO PARSER RTF (Sem alterações aqui)
  // ===================================================================

  const CP1252 = (() => {
    const map = [];
    for (let i=0;i<256;i++) map[i] = String.fromCharCode(i);
    const spec = {0x80:'€',0x82:'‚',0x83:'ƒ',0x84:'„',0x85:'…',0x86:'†',0x87:'‡',0x88:'ˆ',0x89:'‰',0x8A:'Š',0x8B:'‹',0x8C:'Œ',0x8E:'Ž',0x91:'‘',0x92:'’',0x93:'“',0x94:'”',0x95:'•',0x96:'–',0x97:'—',0x98:'˜',0x99:'™',0x9A:'š',0x9B:'›',0x9C:'œ',0x9E:'ž',0x9F:'Ÿ'};
    for (const k in spec) map[+k] = spec[k];
    return map;
  })();

  function hexByteToChar(hh) {
    const n = parseInt(hh, 16);
    return Number.isFinite(n) ? CP1252[n] || '' : '';
  }

  function readBalanced(src, start) {
    let i = start, depth = 0;
    do {
      const ch = src[i++];
      if (ch === '\\') { const next = src[i]; if (next === '{' || next === '}' || next === '\\') i++; continue; }
      if (ch === '{') depth++; else if (ch === '}') depth--;
    } while (i < src.length && depth > 0);
    return { end: i, text: src.slice(start, i) };
  }

  function stripRtf(rtfChunk) {
    let s = rtfChunk;
    if (s[0] === '{' && s[s.length-1] === '}') s = s.slice(1, -1);
    s = s.replace(/\\\\/g, '\\').replace(/\\\{/g, '{').replace(/\\\}/g, '}');
    s = s.replace(/\\u(-?\d+)([^\d-])?/g, (_, num) => { try { return String.fromCodePoint(parseInt(num, 10)); } catch { return ''; } });
    s = s.replace(/\\'([0-9a-fA-F]{2})/g, (_, hh) => hexByteToChar(hh));
    s = s.replace(/\\par\b/g, '\n\n').replace(/\\line\b/g, '\n').replace(/\\tab\b/g, '\t');
    s = s.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');
    s = s.replace(/[{}]/g, '');
    return s;
  }
  
  function parseFieldAt(rtf, start) {
    const { end, text: group } = readBalanced(rtf, start);
    let resultText = '';
    const idx = group.search(/\\fldrslt\b/i);
    if (idx !== -1) {
      const after = group.slice(idx);
      const bracePos = after.indexOf('{');
      if (bracePos !== -1) {
        const inner = readBalanced(after, bracePos);
        resultText = stripRtf(inner.text);
      } else {
        resultText = stripRtf(after.replace(/^\\fldrslt\b/, ''));
      }
    }
    return { html: resultText, end };
  }

  const SKIP_GROUPS = new Set(['fonttbl','colortbl','stylesheet','info','*symbol','*panose','*generator','pict','nonshppict','object','*datastore','filetbl','revtbl','rsidtbl','*rsidtbl','shpinst','shppict','*xmlopen','*xmlnstbl','xmlopen','xe','tc','mmath','*mmathPr']);

  function shouldSkipGroup(name) {
    if (!name) return false;
    const n = name.toLowerCase();
    return SKIP_GROUPS.has(n) || n === '*';
  }

  function rtfToText(rtf) {
    let i = 0, text = '';
    const len = rtf.length;
    while (i < len) {
      const ch = rtf[i];
      if (ch === '{') {
        const m = rtf.slice(i + 1, i + 50).match(/^\\\*?([A-Za-z]+)/);
        const name = m && m[1] ? m[1].toLowerCase() : '';
        if (name === 'field') {
          const { html: h, end } = parseFieldAt(rtf, i);
          text += h;
          i = end;
          continue;
        }
        if (shouldSkipGroup(name)) {
          const { end } = readBalanced(rtf, i);
          i = end;
          continue;
        }
        i++; continue;
      }
      if (ch === '}') { i++; continue; }
      if (ch === '\\') {
        const next = rtf[i+1];
        if (next === '{' || next === '}' || next === '\\') { text += next; i += 2; continue; }
        if (next === "'") {
          const hh = rtf.slice(i+2, i+4);
          if (/^[0-9a-fA-F]{2}$/.test(hh)) { text += hexByteToChar(hh); i += 4; continue; }
        }
        
        const mu = rtf.slice(i).match(/^\\u(-?\d+)(.)?/);
        if (mu) {
          let code = parseInt(mu[1], 10);
          if (code < 0) { code += 65536; }
          try { text += String.fromCodePoint(code); } catch {}
          i += mu[0].length;
          continue;
        }
        
        const mw = rtf.slice(i).match(/^\\([a-zA-Z]+)(-?\d+)?\s?/);
        if (mw) {
          const word = mw[1].toLowerCase();
          switch (word) {
            case 'par': text += '\n\n'; break;
            case 'line': text += '\n'; break;
            case 'tab': text += '\t'; break;
            case 'emdash': text += '—'; break;
            case 'endash': text += '–'; break;
            case 'lquote': text += '‘'; break;
            case 'rquote': text += '’'; break;
            case 'ldblquote': text += '“'; break;
            case 'rdblquote': text += '”'; break;
          }
          i += mw[0].length;
          continue;
        }
        i++; continue;
      }
      text += ch;
      i++;
    }
    return text.replace(/\n{3,}/g, '\n\n').replace(/^[ \t]+|[ \t]+$/gm, '').trim();
  }

  // Listener do input de arquivo (sem alterações)
  document.getElementById('fileInput').addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      const rtfContent = String(reader.result || '');
      // Reutiliza a função que processa e preenche o textarea
      preencherInputComRTF(rtfContent);
    };
    reader.onerror = () => {
      alert('Não foi possível ler o arquivo. Tente novamente.');
    };
    reader.readAsText(f);
  });
  
  // ===================================================================
  // === NOVA FUNÇÃO PARA CARREGAR DA URL ===
  // ===================================================================
  window.carregarDaURL = async function() {
    const urlInput = document.getElementById('urlInput');
    const statusEl = document.getElementById('urlStatus');
    const url = urlInput.value.trim();

    if (!url) {
      alert('Por favor, insira uma URL.');
      return;
    }

    // Usaremos um proxy para evitar problemas de CORS
    // O serviço allorigins.win é gratuito e simples de usar
    const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
    
    statusEl.textContent = 'Carregando...';

    try {
      const response = await fetch(proxyUrl);
      if (!response.ok) {
        throw new Error(`Erro na rede: ${response.status} ${response.statusText}`);
      }
      const rtfContent = await response.text();
      
      // Sucesso! Agora usamos a mesma lógica do carregador de arquivos
      preencherInputComRTF(rtfContent);
      statusEl.textContent = 'Sucesso!';
      
    } catch (error) {
      console.error('Falha ao carregar a URL:', error);
      statusEl.textContent = 'Erro!';
      alert('Não foi possível carregar o conteúdo da URL. Verifique se a URL está correta e tente novamente.');
    } finally {
      // Limpa a mensagem de status após alguns segundos
      setTimeout(() => {
        statusEl.textContent = '';
      }, 3000);
    }
  }
  
  // ===================================================================
  // === NOVA FUNÇÃO PARA CENTRALIZAR O PROCESSAMENTO DO RTF ===
  // ===================================================================
  // Tanto o carregador de arquivo quanto o de URL usarão esta função
  // para evitar repetir código.
  function preencherInputComRTF(rtfContent) {
    let plainText = rtfToText(rtfContent);
    plainText = plainText.replace(/^\*WTS5;\s*/, ''); // Remove um cabeçalho específico
    document.getElementById('inputArea').value = plainText;
  }


  // ===================================================================
  // FIM DO PARSER RTF. A LÓGICA ORIGINAL DA PIPELINE COMEÇA AQUI.
  // (Sem alterações a partir daqui)
  // ===================================================================

  // Funções da pipeline e botões
  function processarReferencias(str) {
    if (!str) return str;
    str = str.replace(/(Salmo[s]?|SALMO[S]?)\s+(\d+)\s+versículo[s]?\s+(\d+)(?:\s*,\s*(\d+))?(?:\s*a\s*(\d+))?/gi, function(_m, livro, num, v1, v2, vfaixa) { if (vfaixa) return `${livro} ${num}:${v1}-${vfaixa}`; if (v2) return `${livro} ${num}:${v1}, ${v2}`; return `${livro} ${num}:${v1}`; });
    str = str.replace(/\b[Pp]rimeir[ao]\s+(?=[A-ZÀ-Ú])/g, '1 ');
    str = str.replace(/\b[Ss]egund[ao]\s+(?=[A-ZÀ-Ú])/g, '2 ');
    str = str.replace(/\b[Tt]erceira?\s+(?=[A-ZÀ-Ú])/g, '3 ');
    str = str.replace(/((?:[1-3]\s+)?[A-ZÀ-Úa-zà-ú][\wÀ-ÿ\s]+?)\s+cap[íi]tulo\s+(\d+)\s+(versículo|versículos)\s+(\d+)(?:\s*,\s*(\d+))?(?:\s*a\s*(\d+))?/gi, function (_m, livro, cap, _tipo, v1, v2, vfaixa) { if (vfaixa) return `${livro} ${cap}:${v1}-${vfaixa}`; if (v2) return `${livro} ${cap}:${v1}, ${v2}`; return `${livro} ${cap}:${v1}`; });
    str = str.replace(/(^|(?:[;,]\s*|\s+[Ee]\s+))([Cc]ap[íi]tulo)s?\s+(\d+)\s+(versículo|versículos)\s+(\d+)(?:\s*,\s*(\d+))?(?:\s*a\s*(\d+))?/g, function (match, sep, _capWord, cap, _tipo, v1, v2, vfaixa, offset, s) { const left = s.slice(0, offset); const reLivro = /((?:[1-3]\s+)?[A-ZÀ-Úa-zà-ú][\wÀ-ÿ\s]+?)\s+\d+:\d+(?:\s*[-,]\s*\d+)?/g; let m, ultimoLivro = null; while ((m = reLivro.exec(left)) !== null) ultimoLivro = (m[1] || '').trim(); if (!ultimoLivro) return match; const vers = vfaixa ? `${cap}:${v1}-${vfaixa}` : (v2 ? `${cap}:${v1}, ${v2}` : `${cap}:${v1}`); return (sep || '') + vers; });
    return str;
  }
  function abreviarLivrosBiblicos(texto) {
    if (typeof abreviacoesBiblicas !== 'object') return texto;
    const livros = Object.keys(abreviacoesBiblicas).sort((a, b) => b.length - a.length);
    livros.forEach(livro => { const reg = new RegExp(`\\b${livro}\\s(?=\\d+:)`, 'g'); texto = texto.replace(reg, abreviacoesBiblicas[livro] + ' '); });
    return texto;
  }
  function tratarImagens(texto) {
    let out = '', i = 0, imgCount = 0;
    function acharFimSentencaInteligente(s, from) { const reQ = /[!?…](?:["')»”’])?/g; reQ.lastIndex = from; const mQ = reQ.exec(s); const idxQ = mQ ? reQ.lastIndex : -1; const reP = /\.(?:["')»”’])?(?=\s+(?:[A-ZÀ-ÖØ-Þ“"(]|$))/g; reP.lastIndex = from; const mP = reP.exec(s); const idxP = mP ? reP.lastIndex : -1; if (idxQ !== -1 && (idxP === -1 || idxQ < idxP)) return idxQ; if (idxP !== -1) return idxP; const nl = s.indexOf('\n', from); return nl === -1 ? s.length : nl; }
    const reImagem = /\[Imagem:/gi;
    let m;
    while ((m = reImagem.exec(texto))) {
      const inicio = m.index;
      out += texto.slice(i, inicio);
      const idxLegendaRel = texto.slice(inicio).search(/Legenda:/i);
      if (idxLegendaRel === -1) { out += texto.slice(inicio, reImagem.lastIndex); i = reImagem.lastIndex; continue; }
      const idxLegendaAbs = inicio + idxLegendaRel;
      const afterLegenda = idxLegendaAbs + 'Legenda:'.length;
      const eol = texto.indexOf('\n', afterLegenda);
      const fimLegenda = (eol === -1 ? texto.length : eol);
      let j = fimLegenda;
      while (j < texto.length && /\s/.test(texto[j])) j++;
      if (j >= texto.length) { out += `<div class="imagem${++imgCount}"></div>\n\n`; i = j; reImagem.lastIndex = i; continue; }
      const numMatch = texto.slice(j).match(/^(\d+(?:-\d+)?\.)\s*/);
      const inicioBuscaFim = numMatch ? j + numMatch[0].length : j;
      let fimProx = acharFimSentencaInteligente(texto, inicioBuscaFim);
      if (fimProx === -1) { const nl = texto.indexOf('\n', j); fimProx = nl === -1 ? texto.length : nl; }
      const proximaSentenca = texto.slice(j, fimProx).trim();
      out += `<div class="imagem${++imgCount}"></div>\n\n` + proximaSentenca;
      i = fimProx;
      reImagem.lastIndex = i;
    }
    out += texto.slice(i);
    return out;
  }

  window.processar = function() {
    let texto = document.getElementById('inputArea').value;
    texto = tratarImagens(texto);
    texto = texto.replace(/\[Quadro\]\s*Objetivo\s*\n+([\s\S]*?)\s*\[Fim do quadro\.\]/gi, (_m, conteudo) => 'Objetivo\n' + (conteudo || '').trim());
    texto = texto.replace(/\(\s*\*\s*\)/g, '*');
    texto = texto.replace(/\[Nota para o leitor\.\][\s\S]*?\[Fim da nota para o leitor\.\]/g, '');
    texto = texto.replace(/([^\n])\n(\[Imagem:])/g, '$1\n\n$2');
    texto = texto.replace(//g, '• ');
    texto = texto.replace(/\n?(Pergunta\s+\d+(\s+a\s+\d+)?)/g, '\n\n$1');
    texto = texto.replace(/Pergunta\s+(\d+)\s+a\s+(\d+)\./g, '$1-$2.');
    texto = texto.replace(/Pergunta\s+(\d+)\./g, '$1.');
    texto = texto.replace(/\(([^)]+)\)/g, (match, dentro) => '(' + processarReferencias(dentro) + ')');
    texto = texto.replace(/(—\s*)([^.\n]+)/g, (match, trav, refs) => trav + processarReferencias(refs));
    texto = processarReferencias(texto);
    texto = texto.replace(/([^\n])\n([^\n\.\:\[\d][^\n\.\:\[]*)\n/g, (match, prev, titulo) => prev + '\n\n' + titulo + '\n');
    let notasRodape = [];
    texto = texto.replace(/\[Nota\]([\s\S]*?)\[Fim da nota\.\]/g, function(_m, conteudo) { let idx = notasRodape.length; let simbolo = ['*', '#', '+'][idx] || '+'; conteudo = (conteudo || '').trim().replace(/^([*#+])\s*/, ''); notasRodape.push(simbolo + ' ' + conteudo); return ''; });
    let notas = [];
    texto = texto.replace(/\[Nota[\s\S]*?\[Fim da nota\.\]/g, (m) => { notas.push(m.trim()); return ''; });
    texto = texto.replace(/\[Leitura[\s\S]*?\[Fim da leitura\.\]/g, '');
    let todasNotas = notasRodape.concat(notas);
    if (todasNotas.length > 0) { texto = texto.trim() + '\n\n' + todasNotas.join('\n\n'); }
    texto = abreviarLivrosBiblicos(texto);
    document.getElementById('outputArea').value = texto.trim();
    const copyBtn = document.getElementById('copyBtn');
    copyBtn.classList.remove('btn-success');
    copyBtn.innerText = 'Copiar';
    const sendBtn = document.getElementById('sendBtn');
    sendBtn.classList.remove('btn-success');
    sendBtn.innerText = 'Enviar para TXT2';
  }
  window.copiarResultado = function() {
    const output = document.getElementById('outputArea');
    if (!output.value.trim()) return;
    output.select();
    document.execCommand('copy');
    const btn = document.getElementById('copyBtn');
    btn.classList.add('btn-success');
    btn.innerText = 'Copiado!';
    setTimeout(() => { btn.classList.remove('btn-success'); btn.innerText = 'Copiar'; }, 1300);
  }
  window.enviarParaTXT2 = function() {
    if (!document.getElementById('outputArea').value.trim() && document.getElementById('inputArea').value.trim()) { window.processar(); }
    const conteudo = document.getElementById('outputArea').value.trim();
    if (!conteudo) { alert('Nada a enviar. Processe um texto primeiro.'); return; }
    localStorage.setItem('TXT2_SEMENTE', conteudo);
    const btn = document.getElementById('sendBtn');
    btn.classList.add('btn-success');
    btn.innerText = 'Enviado!';
    window.location.href = 'txt2.html';
  }
})();
</script>
</body>
</html>