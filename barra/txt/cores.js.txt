// cores.js — Plugin “Cores” (slot 6) com ícones “A” dinâmicos (Texto/Fundo)
// - iOS-safe: salva/restaura seleção ao abrir o color picker
// - Atualiza indicadores em tempo real (input) e opcionalmente ao mudar o cursor
// - Integra com window.toolbar (se existir) e cai pra injeção direta no slot 6

class CoresPlugin {
  constructor() {
    this.name = 'cores';
    this.slotId = 6;

    // refs
    this.editor = null;
    this.slotEl = null;
    this.containerEl = null;

    this.textInput = null;
    this.bgInput = null;
    this.textLabel = null;
    this.bgLabel = null;

    this.textIndicator = null;
    this.bgIndicator = null;

    this.savedRange = null;
    this.selectionListener = null;

    // timers
    this._retryMs = 120;

    this.autoInit();
  }

  /* ========== BOOT/REGISTRO ========== */
  autoInit() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this._afterDOM());
    } else {
      this._afterDOM();
    }
  }

  _afterDOM() {
    this.waitForEditor(() => {
      this.mountIntoSlot().then(() => {
        this.wireEvents();
        // Reflete cores atuais (se houver algo no cursor)
        this.refreshIndicatorsFromSelection();
        // Observa mudanças de seleção p/ refletir estado ao navegar pelo texto
        this.attachSelectionChange();
      });
    });
  }

  waitForEditor(cb) {
    if (window.editor && window.editor.editorElement) {
      this.editor = window.editor;
      cb();
      return;
    }
    setTimeout(() => this.waitForEditor(cb), this._retryMs);
  }

  async mountIntoSlot() {
    // Tenta usar a toolbar se existir
    this.slotEl = document.querySelector(`#plugin-slot-${this.slotId}`);
    const container = this.slotEl ? this.slotEl.querySelector('.plugin-container') : null;

    // Carrega HTML do plugin (arquivo irmão)
    const html = await this.loadPluginHTML();

    if (window.toolbar && typeof window.toolbar.isSlotAvailable === 'function') {
      // Se a toolbar gerencia estado, apenas injeta no contêiner do slot
      if (this.slotEl) this.slotEl.classList.remove('empty');
      if (container) {
        container.innerHTML = html;
        this.containerEl = container.firstElementChild || container;
      }
    } else {
      // Fallback: injeção direta no DOM do slot 6
      if (!this.slotEl) {
        console.warn('[cores] Slot 6 não encontrado; criando fallback.');
        const shelf = document.querySelector('.toolbar-shelf');
        if (!shelf) throw new Error('[cores] toolbar-shelf não encontrada.');
        this.slotEl = document.createElement('div');
        this.slotEl.className = 'plugin-slot';
        this.slotEl.dataset.slot = String(this.slotId);
        this.slotEl.id = `plugin-slot-${this.slotId}`;
        const wrapper = document.createElement('div');
        wrapper.className = 'plugin-container';
        this.slotEl.appendChild(wrapper);
        shelf.appendChild(this.slotEl);
      }
      this.slotEl.classList.remove('empty');
      const container2 = this.slotEl.querySelector('.plugin-container');
      container2.innerHTML = html;
      this.containerEl = container2.firstElementChild || container2;
    }

    // Cache de elementos
    this.textInput     = this.containerEl.querySelector('#text-color-input');
    this.bgInput       = this.containerEl.querySelector('#bg-color-input');
    this.textLabel     = this.containerEl.querySelector('#text-color-label');
    this.bgLabel       = this.containerEl.querySelector('#bg-color-label');
    this.textIndicator = this.containerEl.querySelector('[data-role="text-indicator"]');
    this.bgIndicator   = this.containerEl.querySelector('[data-role="bg-indicator"]');

    // Defaults visuais
    if (this.textIndicator && !this.textIndicator.style.color) {
      this.textIndicator.style.color = '#111111';
    }
    if (this.bgIndicator && !this.bgIndicator.style.backgroundColor) {
      this.bgIndicator.style.backgroundColor = '#fff59d'; // amarelinho “marca-texto”
      this.bgIndicator.style.color = this.contrastColor('#fff59d');
    }
  }

  async loadPluginHTML() {
    // Caminho padrão no teu projeto
    const url = 'barra/plugin/cores/cores.html';
    try {
      const res = await fetch(url, { cache: 'no-cache' });
      if (!res.ok) throw new Error(String(res.status));
      return await res.text();
    } catch (e) {
      console.warn('[cores] Falha ao carregar cores.html. Usando template embutido.', e);
      // Template de backup: mantém a mesma estrutura/ids/classes
      return `
        <div class="cores-plugin" role="group" aria-label="Cores de texto e fundo">
          <input type="color" id="text-color-input" class="color-input-hidden" aria-hidden="true" tabindex="-1">
          <input type="color" id="bg-color-input"   class="color-input-hidden" aria-hidden="true" tabindex="-1">

          <label for="text-color-input" id="text-color-label" class="format-btn color-picker-label" title="Cor do texto" aria-label="Cor do texto">
            <span class="color-indicator text" data-role="text-indicator">A</span>
          </label>

          <label for="bg-color-input" id="bg-color-label" class="format-btn color-picker-label" title="Cor de fundo" aria-label="Cor de fundo">
            <span class="color-indicator bg" data-role="bg-indicator">A</span>
          </label>
        </div>
      `;
    }
  }

  /* ========== EVENTOS / APLICAÇÃO ========== */
  wireEvents() {
    // Salva seleção antes de abrir o color picker (móvel/iOS)
    const saveSel = () => this.saveSelection();
    ['pointerdown','mousedown','touchstart'].forEach(ev => {
      this.textLabel?.addEventListener(ev, saveSel, { passive: true });
      this.bgLabel?.addEventListener(ev, saveSel, { passive: true });
    });

    // Ao escolher cor (input), aplica e atualiza indicadores
    this.textInput?.addEventListener('input', (e) => {
      const val = e.target.value;
      this.applyColor('foreColor', val);
      this.updateTextIndicator(val);
    });

    this.bgInput?.addEventListener('input', (e) => {
      const val = e.target.value;
      // Safari costuma aceitar 'hiliteColor'; se falhar, tenta 'backColor'
      const ok = this.applyColor('hiliteColor', val);
      if (!ok) this.applyColor('backColor', val);
      this.updateBgIndicator(val);
    });
  }

  attachSelectionChange() {
    // Reflete a cor atual do trecho onde o cursor está
    const handler = () => this.refreshIndicatorsFromSelection();
    document.addEventListener('selectionchange', handler);
    this.selectionListener = handler;
  }

  detachSelectionChange() {
    if (this.selectionListener) {
      document.removeEventListener('selectionchange', this.selectionListener);
      this.selectionListener = null;
    }
  }

  /* ========== SELEÇÃO ========== */
  saveSelection() {
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0);
    // Só salva se a seleção estiver dentro do editor
    if (this.editor && this.editor.editorElement && this.editor.editorElement.contains(range.commonAncestorContainer)) {
      this.savedRange = range.cloneRange();
    }
  }

  restoreSelection() {
    if (!this.savedRange) return false;
    const sel = window.getSelection();
    if (!sel) return false;
    sel.removeAllRanges();
    sel.addRange(this.savedRange);
    // Limpa após uso para evitar lixo
    this.savedRange = null;
    return true;
  }

  /* ========== APLICAÇÃO DE COR ========== */
  applyColor(command, color) {
    if (!this.editor || !this.editor.editorElement) return false;

    // Garante foco no editor antes de restaurar a seleção
    this.editor.editorElement.focus();
    const restored = this.restoreSelection();
    if (!restored) {
      // Se não houver seleção salva, ainda podemos aplicar estado “pendente”
      // (o próximo texto digitado herda a cor)
    }

    try {
      const ok = document.execCommand(command, false, color);
      return ok !== false; // alguns navegadores retornam true/false
    } catch (_) {
      return false;
    }
  }

  /* ========== INDICADORES ========== */
  updateTextIndicator(color) {
    if (this.textIndicator) {
      this.textIndicator.style.color = color;
    }
  }

  updateBgIndicator(color) {
    if (this.bgIndicator) {
      this.bgIndicator.style.backgroundColor = color;
      this.bgIndicator.style.color = this.contrastColor(color);
    }
  }

  refreshIndicatorsFromSelection() {
    const info = this.getColorsAtCaret();
    if (info.text) this.updateTextIndicator(info.text);
    if (info.bg)   this.updateBgIndicator(info.bg);
  }

  getColorsAtCaret() {
    const out = { text: null, bg: null };
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return out;
    const range = sel.getRangeAt(0);
    const root = this.editor?.editorElement;
    if (!root || !root.contains(range.commonAncestorContainer)) return out;

    // Tenta queryCommandValue primeiro
    try {
      const fore = document.queryCommandValue('foreColor');     // ex: rgb(34, 34, 34)
      const back = (document.queryCommandValue('hiliteColor') || document.queryCommandValue('backColor')); // ex: rgb(255,255,0)
      if (fore) out.text = this.rgbToHex(fore) || fore;
      if (back && back !== 'transparent') out.bg = this.rgbToHex(back) || back;
    } catch (_) { /* continua */ }

    // Complementa com computedStyle do nó no caret (melhor heurística)
    const node = range.startContainer.nodeType === 1
      ? range.startContainer
      : range.startContainer.parentElement;

    if (node) {
      const cs = getComputedStyle(node);
      if (!out.text && cs.color) out.text = this.rgbToHex(cs.color) || cs.color;
      if (!out.bg && cs.backgroundColor && cs.backgroundColor !== 'rgba(0, 0, 0, 0)') {
        out.bg = this.rgbToHex(cs.backgroundColor) || cs.backgroundColor;
      }
    }
    return out;
  }

  /* ========== UTILITÁRIOS DE COR ========== */
  rgbToHex(rgb) {
    if (!rgb) return null;
    const m = rgb.replace(/\s+/g,'').match(/^rgba?\((\d+),(\d+),(\d+)(?:,([\d.]+))?\)$/i);
    if (!m) return null;
    const r = Number(m[1])|0, g = Number(m[2])|0, b = Number(m[3])|0;
    const hex = '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
    return hex;
  }

  hexToRgb(hex) {
    if (!hex || typeof hex !== 'string') return null;
    const m = hex.trim().match(/^#?([0-9a-f]{6}|[0-9a-f]{3})$/i);
    if (!m) return null;
    let h = m[1];
    if (h.length === 3) h = h.split('').map(c => c + c).join('');
    const int = parseInt(h, 16);
    return { r: (int >> 16) & 255, g: (int >> 8) & 255, b: int & 255 };
  }

  contrastColor(hex) {
    const rgb = this.hexToRgb(hex);
    if (!rgb) return '#111111';
    // luminância relativa (WCAG)
    const srgb = ['r','g','b'].map(k => {
      let v = rgb[k] / 255;
      return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
    });
    const L = 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
    return L > 0.5 ? '#111111' : '#FFFFFF';
  }

  /* ========== CLEANUP ========== */
  destroy() {
    this.detachSelectionChange();
    this.savedRange = null;
  }
}

// Instância global
const coresPlugin = new CoresPlugin();